#!/usr/bin/env python
"""
Help handle backend processes for storing sortable list results

separate tab:

    cd /c/public/sortable_list/web
    python application.py

or for production, use uwsgi:

    uwsgi uwsgi.ini

FAQ:

AttributeError: 'NoneType' object has no attribute 'dimensions'

This is caused by garbage files generated by apple operating systems
Files that start with ._ and litter the filesystem

Rather than handle and ignore this condition
it's better to clean the garbage up

the best solution I've found for this is to remove the garbage files created by OSX... these are the "._*" files created for finder

    find * -name "._*" -exec rm \{\} \;

via 2017.02.04 13:49:08
/c/public/moments/moments/path.py

#seem to be seeing 0kb files from android with jpg extensions...
#nothing useful there

    find * -size 0b -name "*.jpg" -exec rm \{\} \;

*2019.01.27 12:33:09
may need to increase this value in bottle.py
some posts to save a list can get quite long
if this value is not big enough, it will fail silently on save!
MEMFILE_MAX = 102400

"""
from __future__ import print_function

import sys
import os
import re

#from moments.path import Path
from sortable.path import Path
from moments.launch import edit, file_browse
from moments.timestamp import Timestamp

from sortable.gaze import gaze

import bottle
# DO NOT USE THIS IN PRODUCTION!!
bottle.debug(True)

server_root = os.path.dirname(os.path.realpath(__file__))
# print("Server root: %s" % server_root)

# default is "./views/" directory
template_path = os.path.join(server_root, 'templates')
# bottle.TEMPLATE_PATH.append('./templates/')
bottle.TEMPLATE_PATH.append(template_path)

try:
    import simplejson as json
except:
    try:
        import json
    except:
        print("No json module found")
        exit()

#https://stackoverflow.com/questions/17262170/bottle-py-enabling-cors-for-jquery-ajax-requests
class EnableCors(object):
    name = 'enable_cors'
    api = 2

    def apply(self, fn, context):
        def _enable_cors(*args, **kwargs):
            # set CORS headers
            bottle.response.headers['Access-Control-Allow-Origin'] = '*'
            bottle.response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, OPTIONS'
            bottle.response.headers['Access-Control-Allow-Headers'] = 'Origin, Accept, Content-Type, X-Requested-With, X-CSRF-Token'

            if bottle.request.method != 'OPTIONS':
                # actual request; reply with the actual response
                return fn(*args, **kwargs)

        return _enable_cors

server = application = bottle.Bottle()
server.install(EnableCors())


# ROUTES
# Be careful when specifying a relative root-path such as root='./static/files'
# The working directory (./) and the project directory are not always the same.
@server.route('/css/<filename:path>')
def css_static(filename):
    css_path = os.path.join(server_root, 'css')
    print(css_path)
    # return static_file(filename, root='./css')
    return bottle.static_file(filename, root=css_path)


@server.route('/js/<filename:path>')
def js_static(filename):
    js_path = os.path.join(server_root, 'js')
    return bottle.static_file(filename, root=js_path)


@server.route('/img/<filename:path>')
def images_static(filename):
    image_path = os.path.join(server_root, 'img')
    return bottle.static_file(filename, root=image_path)


@server.route('/path/launch/<source:path>')
def launch_path(source=''):
    global path_root
    path = Path(path_root + source, relative_prefix=path_root)

    # just assume the whole thing has been sent
    # path = Path(source)

    response = ''
    if path.type() == "Log":
        edit(path)
        response += "editing: %s<br>" % path
    elif path.type() == "Directory":
        file_browse(path)
        response += "browsing: %s<br>" % path
    else:
        response += "unknown type: %s for: %s<br>" % (path.type(), path)

    response += "LAUNCH PATH: %s<br>" % source
    return response

# to force a download, use the following:
#    return bottle.static_file(filename, root='/path/to/static/files', download=filename)


@server.post('/save/<relative:path>')
@server.post('/save/')
@server.post('/save')
def save(relative=''):
    # debug:
    # print(dir(bottle.request.forms))
    # print("Keys: %s" % (bottle.request.forms.keys()))
    # print("Values: %s" % (bottle.request.forms.values()))

    global path_root

    if re.match('~', relative):
        relative = os.path.expanduser(relative)

    if not relative:
        # could set a default here if it is desireable
        print("NO DESTINATION SENT!")
    elif not re.match('/', relative):
        relative = path_root + relative

    # destination = Path(relative, relative_prefix=path_root)
    # now check if the destination is a directory...
    # in that case, create a sortable.list name in the directory
    if os.path.isdir(relative):
        print("Relative directory passed in:", relative)
        path = Path(relative)
        print("Path loaded:", path)

        name = path.name + ".list"
        destination = os.path.join(relative, name)
        # TODO:
        # something recursive can happen here:
        # having difficulty replicating...
        # should work though!
        # destination = path.sortable_list_path()

        print("Destination:", destination)

        log_name = path.name + ".list.log"
        log_destination = os.path.join(relative, log_name)

    else:
        destination = relative
        log_destination = relative + ".log"

    # print(destination)

    # gets a string
    # could be json or text / list
    content = bottle.request.forms.get('content')
    # print("CONTENT:")
    # print(content)
    # print()

    save_as = bottle.request.forms.get('format')

    if destination:
        if save_as in ["list"]:
            dest_file = open(destination, 'w')
            # print("opened: ", destination)
            # print("writing (raw): ", content)
            dest_file.write(content)
            dest_file.close()
            print("saved content to: ", destination)

            # TODO:
            # check the .list.log file to see if today's entry already exists
            log_path = Path(log_destination)
            print("Log path: ", log_path)
            if log_path.exists():
                j = log_path.load_journal()
            else:
                j = log_path.load_journal(create=True)
            now = Timestamp()
            now.compact(accuracy='day')
            entries = j.range(now)
            print(entries)
            if len(entries):
                print("already had today logged")
            else:
                j.make(content, created=now)
                j.save(log_path)
                print("adding new entry")



            # this should be sufficient
            return("Success!")
        else:
            return("Unknown format: " + str(save_as))


        ## elif save_as == "json":
        ##     #could also do something like:
        ##     ordered_list = json.loads(content)
        ##     save_json(destination, ordered_list)
        ##     #but that seems like the same thing as above

        # if save() is being called via ajax,
        # redirecting here only causes extra load on the server
        # redirect("/text" + relative)
        # redirect("/path" + relative)

    else:
        return("No destination specified")


@server.route('/image/<relative:path>')
def image(relative=''):
    global path_root

    # if not re.match('/', relative):
    #    relative = os.path.join(path_root, relative)

    # print()"SHOWING IMAGE: %s" % relative)
    path = Path(relative, relative_prefix=path_root)
    if path.type() == "Image":
        return bottle.static_file(relative, root=path_root)
    else:
        # TODO: raise 404
        pass


@server.route('/file/<relative:path>')
def serve_file(relative=''):
    """
    """
    global path_root

    #if not re.match('/', relative):
    #    relative = os.path.join(path_root, relative)

    #print "SHOWING IMAGE: %s" % relative
    path = Path(relative, relative_prefix=path_root)
    #if path.type() == "Image":
    return bottle.static_file(relative, root=path_root)
    ## else:
    ##     #TODO: raise 404
    ##     pass


def expand_relative(relative):
    global path_root

    if re.match('~', relative):
        relative = os.path.expanduser(relative)

    full_path = os.path.join(path_root, relative)

    return full_path


@server.route('/text/<relative:path>')
def text(relative=''):
    """
    load a text editor
    start with just a simple form

    this is a low level way of sorting a text based list...
    just edit the order and save the results
    """
    global path_root

    # if not re.match('/', relative):
    #    relative = os.path.join(path_root, relative)

    full_path = expand_relative(relative)

    print("Editing Text: %s" % relative)
    path = Path(full_path, relative_prefix=path_root)
    contents = open(full_path).read()
    if path.type() in ["Log", "List", "JSON"]:
        return bottle.template('editor', path=path, contents=contents)

    else:
        # TODO: raise 404
        pass


@server.route('/copy-up/<relative:path>')
@server.route('/copy/<relative:path>')
def copy_up(relative=''):
    """
    find the item at the supplied path
    and copy it up to the parent directory
    this is useful for images that should show up as the default image
    """
    global path_root

    if re.match('~', relative):
        relative = os.path.expanduser(relative)

    full_path = os.path.join(path_root, relative)
    path = Path(full_path, relative_prefix=path_root)

    if path.type() == "Image":
        cur_dir = path.parent()
        parent = cur_dir.parent()

        path.copy(parent)

        #this should be sufficient
        return "Success!"

    else:
        return "Failed"

@server.route('/json/<relative:path>')
def json_edit(relative=''):
    """
    load a json editor
    """
    global path_root

    # if not re.match('/', relative):
    #    relative = os.path.join(path_root, relative)

    full_path = expand_relative(relative)

    print("showing json: %s" % relative)
    path = Path(full_path, relative_prefix=path_root)
    contents = open(full_path).read()
    items = json.load(open(full_path))
    print(items)
    if path.type() in ["JSON"]:
        return bottle.template('json', path=path, contents=contents, items=items)

    else:
        # TODO: raise 404
        pass

@server.route('/json-path/<relative:path>')
@server.route('/json-path/')
@server.route('/json-path')
def json_path(relative=''):
    """
    serve a path ... either a directory or a file **as a json object** (the list that is generated by gaze)

    !!! WARNING !!!
    this allows the app to function as a customizable file system browser
    be careful with what you set path_root to.
    If the machine you run this on has sensitive information
    and is connected to a public network, it's available
    """
    global path_root

    if re.match('~', relative):
        relative = os.path.expanduser(relative)
    ## else:
    ##     relative = os.path.join('/', relative)
    ##     full = os.path.abspath(relative)
    ## print full

    full_path = os.path.join(path_root, relative)
    path = Path(full_path, relative_prefix=path_root)

    (sl, collection, current) = gaze(full_path)
    print(sl)
    print(current)

    # collection is what we want to return,
    # but first we need to convert the images Paths
    # to
    friendly = []
    for item in collection:
        item['image'] = str(item['image'])
        item['path'] = str(item['path'])
        friendly.append(item)

    return json.dumps(friendly)


@server.route('/path/<relative:path>')
@server.route('/path/')
@server.route('/path')
def path(relative=''):
    """
    serve a path ... either a directory or a file

    !!! WARNING !!!
    this allows the app to function as a customizable file system browser
    be careful with what you set path_root to.
    If the machine you run this on has sensitive information
    and is connected to a public network, it's available
    """
    global path_root

    if re.match('~', relative):
        relative = os.path.expanduser(relative)

    full_path = os.path.join(path_root, relative)
    path = Path(full_path, relative_prefix=path_root)

    (sl, collection, current) = gaze(full_path)

    #current is used to display previous and next options
    if current:
        # might be able to figure these details out in javascript
        # but for now:
        index = collection.index(current)
        if index != 0:
            previous_item = collection[index-1]
        else:
            previous_item = collection[-1]

        if index != len(collection)-1:
            next_item = collection[index+1]
        else:
            next_item = collection[0]

        context = {"path": path,
                   "collection": collection,
                   "content": current,
                   "index": index,
                   "previous": previous_item,
                   "next": next_item,
                   }

        return bottle.template('content', c=context)
    else:
        return bottle.template('collection', path=path, collection=collection)



@server.route('/now')
def now(relative=''):
    return bottle.template('now')



@server.route('/')
def index():
    global path_root
    return bottle.template('home', path_root=path_root)


# GLOBALS:
# this is equivalent to main() function in template_script.py

# requires that at least one argument is passed in to the script itself
# (through sys.argv)
ignores = []

port = 8888
path_root = "/path/to/some/safe/location/"
# this is not a safe path, but it's convenient
path_root = "/"

if __name__ == '__main__':
    # default host:
    host = "localhost"

    if len(sys.argv) > 1:
        helps = ['--help', 'help', '-h']
        for i in helps:
            if i in sys.argv:
                print("python application.py --context [directory to load] [address]")
                exit()

        proots = ['--root', '-r', '-c', '--context']
        for p in proots:
            if p in sys.argv:
                i = sys.argv.index(p)
                sys.argv.pop(i)
                path_root = sys.argv.pop(i)
                sys.argv.pop(i)

        ports = ['--port', '-p']
        for p in ports:
            if p in sys.argv:
                i = sys.argv.index(p)
                sys.argv.pop(i)
                port = sys.argv.pop(i)
                sys.argv.pop(i)

        hosts = ['--host', '--address', '-a']
        for h in hosts:
            if h in sys.argv:
                i = sys.argv.index(h)
                sys.argv.pop(i)
                host = sys.argv.pop(i)
                sys.argv.pop(i)

        # if we still have something left, assume it's an address
        if len(sys.argv) > 1:
            host = sys.argv[1]

    print("Path root: %s" % path_root)

    # start the server loop
    # reloader=True enables Auto Reloading
    # bottle.run(app=server, host='localhost', port=port, reloader=True)
    bottle.run(app=server, host=host, port=port, reloader=True)
